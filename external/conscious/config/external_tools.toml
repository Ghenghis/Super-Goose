# Super-Goose External Tools Registry
# Each tool has a bridge module in src/integrations/ that wraps its functionality
# for use by Goose agents via the Conscious bridge layer.

[registry]
version = "1.0"
bridge_port = 8999        # Conscious API port
goosed_port = 7878        # Goose server port

[tools.aider]
name = "Aider"
description = "AI pair programming with 26+ code editing strategies"
path = "G:/goose/external/aider"
bridge_module = "integrations.aider_bridge"
enabled = true
capabilities = ["code_edit", "repo_map", "auto_commit", "auto_lint", "voice_input"]
entry_point = "aider.main"
python_requires = ">=3.9"
install_cmd = "pip install -e G:/goose/external/aider"

[tools.aider.endpoints]
edit_file = { method = "POST", path = "/api/tools/aider/edit" }
map_repo = { method = "POST", path = "/api/tools/aider/map" }
auto_commit = { method = "POST", path = "/api/tools/aider/commit" }

[tools.conscious]
name = "Conscious"
description = "Voice-first AI companion with emotion detection and personality"
path = "G:/goose/external/conscious"
bridge_module = "integrations.conscious_bridge"
enabled = true
capabilities = ["voice_io", "emotion_detect", "personality", "memory", "device_control"]
entry_point = "conscious.server"
python_requires = ">=3.10"

[tools.conscious.endpoints]
voice_start = { method = "POST", path = "/api/voice/start" }
voice_status = { method = "GET", path = "/api/voice/status" }
voice_audio = { method = "POST", path = "/api/voice/audio" }
voice_stream = { method = "WS", path = "/api/voice/stream" }

[tools.langgraph]
name = "LangGraph"
description = "Graph-based stateful agent workflow orchestration"
path = "G:/goose/external/langgraph"
bridge_module = "integrations.langgraph_bridge"
enabled = true
capabilities = ["workflow", "checkpoint", "human_in_loop", "time_travel", "parallel"]
entry_point = "langgraph"
python_requires = ">=3.10"
install_cmd = "pip install -e G:/goose/external/langgraph/libs/langgraph"

[tools.langgraph.endpoints]
create_workflow = { method = "POST", path = "/api/tools/langgraph/workflow" }
run_workflow = { method = "POST", path = "/api/tools/langgraph/run" }
checkpoint = { method = "GET", path = "/api/tools/langgraph/checkpoint" }
resume = { method = "POST", path = "/api/tools/langgraph/resume" }

[tools.openhands]
name = "OpenHands"
description = "AI software engineer with Docker sandboxed execution"
path = "G:/goose/external/OpenHands"
bridge_module = "integrations.openhands_bridge"
enabled = true
capabilities = ["sandbox_exec", "docker", "browser", "multi_agent", "security_scan"]
entry_point = "openhands"
python_requires = ">=3.12"
install_cmd = "pip install -e G:/goose/external/OpenHands"
requires_docker = true

[tools.openhands.endpoints]
sandbox_exec = { method = "POST", path = "/api/tools/openhands/exec" }
browse = { method = "POST", path = "/api/tools/openhands/browse" }
status = { method = "GET", path = "/api/tools/openhands/status" }

[tools.praisonai]
name = "PraisonAI"
description = "High-performance multi-agent framework with workflow engine"
path = "G:/goose/external/PraisonAI"
bridge_module = "integrations.praisonai_bridge"
enabled = true
capabilities = ["auto_agents", "workflow", "rag", "planning", "100_tools", "mcp"]
entry_point = "praisonaiagents"
python_requires = ">=3.10"
install_cmd = "pip install -e G:/goose/external/PraisonAI/src/praisonai-agents"

[tools.praisonai.endpoints]
create_agents = { method = "POST", path = "/api/tools/praisonai/agents" }
run_workflow = { method = "POST", path = "/api/tools/praisonai/workflow" }
search_knowledge = { method = "POST", path = "/api/tools/praisonai/knowledge" }

[tools.pydantic_ai]
name = "Pydantic-AI"
description = "Type-safe AI agent framework with structured output validation"
path = "G:/goose/external/pydantic-ai"
bridge_module = "integrations.pydantic_ai_bridge"
enabled = true
capabilities = ["typed_output", "validation", "dependency_injection", "durable_exec", "observability"]
entry_point = "pydantic_ai"
python_requires = ">=3.10"
install_cmd = "pip install -e G:/goose/external/pydantic-ai/pydantic-ai-slim"

[tools.pydantic_ai.endpoints]
validate_output = { method = "POST", path = "/api/tools/pydantic-ai/validate" }
run_typed_agent = { method = "POST", path = "/api/tools/pydantic-ai/run" }

# ---------------------------------------------------------------------------
# Stage 6-7: Self-Improvement & Safety Pipeline
# ---------------------------------------------------------------------------

[tools.dspy]
name = "DSPy"
description = "Prompt optimization compiler with GEPA evolutionary optimizer"
path = "G:/goose/external/dspy"
bridge_module = "integrations.dspy_bridge"
enabled = true
capabilities = ["prompt_optimize", "signature_compile", "few_shot", "chain_of_thought", "gepa"]
entry_point = "dspy"
python_requires = ">=3.10"
install_cmd = "pip install dspy"

[tools.dspy.endpoints]
optimize = { method = "POST", path = "/api/tools/dspy/optimize" }
compile = { method = "POST", path = "/api/tools/dspy/compile" }
export_compiled = { method = "POST", path = "/api/tools/dspy/export" }

[tools.inspect_ai]
name = "Inspect AI"
description = "Evaluation harness for scoring agent task attempts against benchmarks"
path = "G:/goose/external/inspect-ai"
bridge_module = "integrations.inspect_bridge"
enabled = true
capabilities = ["benchmark_eval", "scoring", "dataset_load", "swe_bench", "humaneval", "run_eval", "score"]
entry_point = "inspect_ai"
python_requires = ">=3.10"
install_cmd = "pip install inspect-ai"

[tools.inspect_ai.endpoints]
score = { method = "POST", path = "/api/tools/inspect-ai/score" }
load_dataset = { method = "POST", path = "/api/tools/inspect-ai/dataset" }
run_eval = { method = "POST", path = "/api/tools/inspect-ai/eval" }

[tools.mem0]
name = "Mem0"
description = "Graph memory with Neo4j entity-relationship storage and Qdrant vector search"
path = "G:/goose/external/mem0"
bridge_module = "integrations.mem0_bridge"
enabled = true
capabilities = ["graph_memory", "entity_store", "trajectory_store", "vector_search", "relationship_query"]
entry_point = "mem0"
python_requires = ">=3.10"
install_cmd = "pip install mem0ai"

[tools.mem0.endpoints]
store_trajectory = { method = "POST", path = "/api/tools/mem0/trajectory" }
query_memory = { method = "POST", path = "/api/tools/mem0/query" }
add_entity = { method = "POST", path = "/api/tools/mem0/entity" }
search = { method = "POST", path = "/api/tools/mem0/search" }

[tools.microsandbox]
name = "Microsandbox"
description = "MicroVM sandbox for secure agent code execution via MCP-native interface"
path = "G:/goose/external/microsandbox"
bridge_module = "integrations.microsandbox_bridge"
enabled = true
capabilities = ["sandbox_exec", "microvm", "snapshot", "mcp_native", "resource_limit"]
entry_point = "microsandbox"
python_requires = ">=3.10"
install_cmd = "pip install microsandbox"

[tools.microsandbox.endpoints]
create_sandbox = { method = "POST", path = "/api/tools/microsandbox/create" }
run_command = { method = "POST", path = "/api/tools/microsandbox/run" }
destroy_sandbox = { method = "POST", path = "/api/tools/microsandbox/destroy" }
snapshot = { method = "POST", path = "/api/tools/microsandbox/snapshot" }

[tools.arrakis]
name = "Arrakis"
description = "Snapshot and restore MicroVM state for deterministic replay and rollback"
path = "G:/goose/external/arrakis"
bridge_module = "integrations.arrakis_bridge"
enabled = true
capabilities = ["vm_snapshot", "vm_restore", "deterministic_replay", "state_fork"]
entry_point = "arrakis"
python_requires = ">=3.10"
install_cmd = "go build ./cmd/..."

[tools.arrakis.endpoints]
snapshot = { method = "POST", path = "/api/tools/arrakis/snapshot" }
restore = { method = "POST", path = "/api/tools/arrakis/restore" }
list_snapshots = { method = "GET", path = "/api/tools/arrakis/list" }
fork = { method = "POST", path = "/api/tools/arrakis/fork" }

[tools.ast_grep]
name = "ast-grep"
description = "Structural code search and editing using AST pattern matching"
path = "G:/goose/external/ast-grep"
bridge_module = "integrations.ast_grep_bridge"
enabled = true
capabilities = ["structural_search", "ast_edit", "code_pattern", "refactor", "multi_language"]
entry_point = "ast_grep"
install_cmd = "cargo install ast-grep"

[tools.ast_grep.endpoints]
search = { method = "POST", path = "/api/tools/ast-grep/search" }
replace = { method = "POST", path = "/api/tools/ast-grep/replace" }
scan = { method = "POST", path = "/api/tools/ast-grep/scan" }

[tools.semgrep]
name = "Semgrep"
description = "Policy-as-code guardrails for static analysis and security scanning"
path = "G:/goose/external/semgrep"
bridge_module = "integrations.semgrep_bridge"
enabled = true
capabilities = ["static_analysis", "security_scan", "policy_check", "custom_rules", "autofix"]
entry_point = "semgrep"
python_requires = ">=3.10"
install_cmd = "pip install semgrep"

[tools.semgrep.endpoints]
scan = { method = "POST", path = "/api/tools/semgrep/scan" }
check_policy = { method = "POST", path = "/api/tools/semgrep/policy" }
autofix = { method = "POST", path = "/api/tools/semgrep/autofix" }

[tools.crosshair]
name = "CrossHair"
description = "Python formal verification using symbolic execution and contracts"
path = "G:/goose/external/crosshair"
bridge_module = "integrations.crosshair_bridge"
enabled = true
capabilities = ["formal_verify", "symbolic_exec", "contract_check", "property_test", "counterexample"]
entry_point = "crosshair"
python_requires = ">=3.10"
install_cmd = "pip install crosshair-tool"

[tools.crosshair.endpoints]
verify = { method = "POST", path = "/api/tools/crosshair/verify" }
check_contracts = { method = "POST", path = "/api/tools/crosshair/contracts" }
find_counterexample = { method = "POST", path = "/api/tools/crosshair/counterexample" }
check_directory = { method = "POST", path = "/api/tools/crosshair/directory" }
selftest = { method = "POST", path = "/api/tools/crosshair/selftest" }

[tools.langfuse]
name = "Langfuse"
description = "Observability platform for LLM traces, spans, and cost tracking"
path = "G:/goose/external/langfuse"
bridge_module = "integrations.langfuse_bridge"
enabled = true
capabilities = ["tracing", "span_logging", "cost_tracking", "prompt_versioning", "evaluation"]
entry_point = "langfuse"
python_requires = ">=3.10"
install_cmd = "pip install langfuse"

[tools.langfuse.endpoints]
log_trace = { method = "POST", path = "/api/tools/langfuse/trace" }
log_span = { method = "POST", path = "/api/tools/langfuse/span" }
get_metrics = { method = "GET", path = "/api/tools/langfuse/metrics" }

[tools.pr_agent]
name = "PR-Agent"
description = "CI/PR automation with AI-powered code review and description generation"
path = "G:/goose/external/pr-agent"
bridge_module = "integrations.pr_agent_bridge"
enabled = true
capabilities = ["pr_review", "pr_describe", "pr_improve", "ci_feedback", "changelog"]
entry_point = "pr_agent"
python_requires = ">=3.10"
install_cmd = "pip install pr-agent"

[tools.pr_agent.endpoints]
review = { method = "POST", path = "/api/tools/pr-agent/review" }
describe = { method = "POST", path = "/api/tools/pr-agent/describe" }
improve = { method = "POST", path = "/api/tools/pr-agent/improve" }
